<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bingo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cabin+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' https: http: data:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; connect-src https:; script-src 'self' 'unsafe-inline';">

  <style>
    :root {
      --bg-body: #342e25;
      --bg-tile: #494034;
      --bg-well: #342e25;
      --bg-completed: #1e3a1e;
      --bg-completed-well: #162a16;
      --border-main: #6d604e;
      --border-completed: #4caf50;
      --accent: #ffac00;
      --text-main: #ffac00;
      --text-bright: #ffee00;
      --text-dim: #858476;
      --text-completed: #4caf50;
      --danger: #ff6d6d;
    }

    * { box-sizing: border-box; }
    html { scrollbar-gutter: stable; overflow-y: scroll; }

    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px; padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0); border: 0; white-space: nowrap;
    }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-well); }
    ::-webkit-scrollbar-thumb { background: var(--bg-tile); border: 2px solid var(--bg-well); }
    ::-webkit-scrollbar-thumb:hover { background: var(--border-main); }

    body {
      background-color: var(--bg-body);
      color: var(--text-main);
      font-family: 'Cabin Condensed', sans-serif;
      margin: 0; padding: 15px;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh;
    }

    .dashboard {
      width: 100%; max-width: 1580px;
      background: var(--bg-tile); border: 2px solid var(--border-main);
      padding: 10px 20px; margin-bottom: 20px;
      display: flex; justify-content: space-between; align-items: center;
      flex-wrap: wrap; gap: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5); z-index: 100;
    }
    .dashboard-main { display: flex; flex-direction: column; flex: 1; min-width: 0; }
    #event-title {
      font-size: 1.6rem; margin: 0; text-transform: uppercase;
      letter-spacing: 1px; text-shadow: 2px 2px 4px black;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    #team-name {
      font-size: 1.1rem; color: #ffffff; margin: 2px 0 0 0;
      text-shadow: 1px 1px 2px black; font-weight: bold;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .stats-container { display: flex; gap: 15px; align-items: center; flex-shrink: 0; flex-wrap: wrap; }
    .stat-item { text-align: center; }
    .stat-label { font-size: 0.65rem; text-transform: uppercase; color: var(--text-dim); display: block; }
    .stat-value { font-size: 1.3rem; font-weight: bold; color: var(--text-main); }
    #codeword-display {
      cursor: pointer; background: var(--bg-well);
      padding: 2px 10px; border-radius: 0;
      min-width: 90px; text-align: center; display: inline-block;
    }
    .codeword-hidden { color: var(--bg-well); text-shadow: none; }

    .settings-btn {
      background: none; border: 2px solid var(--border-main);
      color: var(--text-dim); width: 38px; height: 38px;
      border-radius: 0; cursor: pointer;
      display: flex; justify-content: center; align-items: center;
      transition: all 0.2s ease; flex-shrink: 0;
      font-size: 1.3rem; padding: 0; order: 10;
    }
    .settings-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--bg-well); }
    .settings-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .settings-btn svg { width: 20px; height: 20px; fill: currentColor; }

    #admin-back-btn {
      width: auto; padding: 0 12px;
      background: var(--bg-well); border-color: var(--accent);
      color: var(--accent); font-weight: bold;
      font-family: 'Cabin Condensed', sans-serif;
      text-transform: uppercase; letter-spacing: 0.5px;
      font-size: 0.9rem; gap: 6px;
    }
    #admin-back-btn:hover { background: var(--accent); color: var(--bg-body); }

    .minimap-wrapper {
      background: var(--bg-well); padding: 4px;
      border: 2px solid var(--border-main); flex-shrink: 0;
      cursor: pointer; transition: transform 0.2s ease, border-color 0.2s ease;
    }
    .minimap-wrapper:hover { transform: scale(1.05); border-color: var(--accent); }
    .minimap-wrapper:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .minimap-container {
      display: grid; grid-template-columns: repeat(var(--grid-cols, 7), 10px);
      grid-template-rows: repeat(var(--grid-rows, 7), 10px); gap: 2px; pointer-events: none;
    }
    .mini-tile {
      width: 10px; height: 10px; background: var(--bg-body);
      display: flex; justify-content: center; align-items: center;
      font-size: 7px; color: rgba(255,255,255,0.2); border-radius: 0;
    }
    .mini-tile.complete { background: var(--bg-completed); color: var(--text-completed); }

    .grid-container {
      display: grid; grid-template-columns: repeat(var(--grid-cols, 7), 1fr);
      gap: 10px; width: 100%; max-width: 1580px;
    }

    .tile {
      background-color: var(--bg-tile); border: 2px solid var(--border-main);
      position: relative; aspect-ratio: 1 / 1;
      display: flex; flex-direction: column; padding: 5%;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5); overflow: hidden;
      container-type: inline-size; cursor: pointer;
      transition: all 0.3s ease, opacity 0.4s ease;
    }
    .tile.completed { background-color: var(--bg-completed); border-color: var(--border-completed); }
    .tile:hover {
      transform: scale(1.05); z-index: 50;
      box-shadow: 0 0 25px 2px var(--accent), inset 0 0 10px rgba(0,0,0,0.5);
    }
    .tile.completed:hover { box-shadow: 0 0 25px 2px var(--border-completed), inset 0 0 10px rgba(0,0,0,0.5); }
    .tile:focus-visible { outline: 3px solid var(--accent); outline-offset: 2px; transform: scale(1.02); z-index: 60; }
    .tile.completed:focus-visible { outline-color: var(--border-completed); }
    .tile.ghost { opacity: 0; pointer-events: none; }

    .header-box {
      padding: 2% 0; margin-bottom: 2%; min-height: 18%;
      display: flex; justify-content: center; align-items: center;
      flex-shrink: 0; overflow: hidden; text-align: center;
    }
    .header-content {
      width: 100%; font-weight: bold; font-size: 8cqw;
      line-height: 1; white-space: nowrap;
      text-shadow: 1px 1px 2px black; color: var(--text-main);
    }
    .tile.completed .header-content { color: var(--text-completed); }

    .img-container {
      height: 40%; display: flex; justify-content: center;
      align-items: center; margin-bottom: 2%; flex-shrink: 0;
    }
    .img-container img {
      max-height: 100%; max-width: 95%; object-fit: contain;
      filter: drop-shadow(2px 3px 4px black);
    }

    .progress-container {
      margin-bottom: 2%; height: 2cqw; min-height: 5px;
      width: 100%; flex-shrink: 0;
    }
    .tile.completed .progress-container { display: none; }
    .progress-bg { background: var(--bg-well); height: 100%; border: 1px solid #000; width: 100%; overflow: hidden; }
    .progress-fill { height: 100%; transition: width 0.5s ease, background-color 0.5s ease; }

    .checklist-box {
      background: var(--bg-well); border: 1px solid #000;
      padding: 3%; flex-grow: 1; width: 100%;
      overflow-y: auto; min-height: 0;
      transition: background 0.3s ease; position: relative;
    }
    .tile.completed .checklist-box { background: var(--bg-completed-well); }
    .tile.completed .checklist-box::-webkit-scrollbar-track { background: var(--bg-completed); }
    .tile.completed .checklist-box::-webkit-scrollbar-thumb { background: var(--bg-completed-well); border: 2px solid var(--bg-completed); }

    .check-item { display: flex; align-items: center; margin-bottom: 4px; }
    .check-mark {
      width: 1.2em; height: 1.2em; margin-right: 6px; flex-shrink: 0;
      position: relative; display: flex; justify-content: center; align-items: center;
    }
    .check-mark::after {
      content: ''; width: 0.3em; height: 0.6em;
      border: solid var(--text-completed); border-width: 0 0.2em 0.2em 0;
      transform: rotate(45deg);
    }
    .tile .check-item { font-size: 6cqw; color: var(--text-bright); }
    .tile.completed .check-item { color: var(--text-completed); }
    .check-item.uncollected {
      color: var(--text-dim);
    }
    .check-item.uncollected .check-mark::after {
      display: none;
    }

    .point-badge {
      position: absolute; bottom: 5px; right: 5px;
      background: var(--bg-well); border: 1px solid var(--accent);
      padding: 1px 5px; border-radius: 0;
      font-size: 10px; font-weight: bold;
      color: var(--text-main); z-index: 10;
    }
    .tile.completed .point-badge {
      border-color: var(--border-completed); color: var(--text-completed);
      background: var(--bg-completed-well);
    }
    .tile.no-data { opacity: 0.55; cursor: default; }
    .tile.no-data:hover { transform: none; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); z-index: auto; }
    .tile.no-data:focus-visible { outline: none; transform: none; }

    #modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0); display: none;
      justify-content: center; align-items: center; z-index: 2000;
      backdrop-filter: blur(0px);
      transition: background 0.4s ease, backdrop-filter 0.4s ease;
    }
    #modal-overlay.active { background: rgba(0,0,0,0.75); backdrop-filter: blur(3px); }

    .modal-content {
      background-color: var(--bg-tile); border: 3px solid var(--border-main);
      width: 95vw; max-width: 650px; padding: 25px;
      position: fixed; box-shadow: 0 0 50px rgba(0,0,0,0.8), 0 0 30px 5px var(--accent);
      display: flex; flex-direction: column;
      opacity: 0; transform: translate(-50%, -50%) scale(0);
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: none; z-index: 2001;
      max-height: 90vh; overflow-y: auto;
    }
    .modal-content.completed {
      background-color: var(--bg-completed); border-color: var(--border-completed);
      box-shadow: 0 0 50px rgba(0,0,0,0.8), 0 0 30px 5px var(--border-completed);
    }
    .modal-content.completed ::-webkit-scrollbar-track { background: var(--bg-completed); }
    .modal-content.completed ::-webkit-scrollbar-thumb { background: var(--bg-completed-well); border-color: var(--bg-completed); }

    .modal-content.active {
      opacity: 1; top: 50% !important; left: 50% !important;
      transform: translate(-50%, -50%) scale(1); pointer-events: auto;
    }

    .modal-header {
      font-size: 1.8rem; margin-bottom: 12px; text-align: center;
      font-weight: bold; color: var(--text-main);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    .modal-content.completed .modal-header { color: var(--text-completed); }

    .modal-img { height: 250px; margin-bottom: 12px; display: flex; justify-content: center; }
    .modal-img img { max-height: 100%; filter: drop-shadow(4px 4px 6px black); }

    .modal-label { font-size: 0.7rem; text-transform: uppercase; font-weight: bold; margin-bottom: 2px; color: var(--text-main); }
    .modal-content.completed .modal-label { color: var(--text-completed); }

    .modal-points-inline {
      font-size: 0.85rem; background: var(--bg-well);
      border: 1px solid var(--accent); padding: 1px 6px;
      border-radius: 0; font-weight: bold; color: var(--text-main);
    }
    .modal-content.completed .modal-points-inline {
      border-color: var(--border-completed); color: var(--text-completed);
      background: var(--bg-completed-well);
    }

    .modal-checklist, .modal-description {
      background: var(--bg-well); border: 1px solid #000;
      padding: 8px; overflow-y: auto; color: var(--text-bright);
    }
    .modal-content.completed .modal-checklist,
    .modal-content.completed .modal-description {
      background: var(--bg-completed-well); color: var(--text-completed);
    }
    .modal-top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0; min-height: 30px; }

    .modal-map-btn {
      background: none; border: none; padding: 4px; cursor: pointer;
      color: var(--text-dim); display: flex; align-items: center;
      justify-content: center; border-radius: 0; transition: all 0.2s ease;
    }
    .modal-map-btn:hover { color: var(--accent); background: var(--bg-well); }
    .modal-map-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .modal-map-btn svg { width: 22px; height: 22px; fill: currentColor; }

    .modal-close-btn {
      background: none; border: none; padding: 4px; cursor: pointer;
      color: var(--text-dim); display: flex; align-items: center;
      justify-content: center; font-size: 2rem; line-height: 1;
      transition: all 0.2s ease; border-radius: 0;
    }
    .modal-close-btn:hover { color: var(--accent); background: var(--bg-well); }
    .modal-close-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .modal-content.completed .modal-map-btn,
    .modal-content.completed .modal-close-btn {
      color: var(--text-completed);
    }
    .modal-content.completed .modal-map-btn:hover,
    .modal-content.completed .modal-close-btn:hover {
      color: var(--bg-completed); background: var(--text-completed);
    }
    .modal-content.completed .modal-map-btn:focus-visible,
    .modal-content.completed .modal-close-btn:focus-visible {
      outline-color: var(--text-completed);
    }

    .large-map-grid {
      display: grid; grid-template-columns: repeat(var(--grid-cols, 7), 1fr);
      gap: 5px; background: var(--bg-body); padding: 10px;
      border: 2px solid var(--border-main); width: 100%; aspect-ratio: 1/1;
    }
    .large-map-tile {
      background: var(--bg-well); display: flex;
      justify-content: center; align-items: center;
      font-size: 1.2rem; font-weight: bold;
      color: rgba(255,255,255,0.2); border: 1px solid var(--bg-tile);
      cursor: pointer; transition: 0.2s;
    }
    .large-map-tile:hover { background: var(--bg-tile); color: #fff; transform: scale(1.05); z-index: 2; border-color: var(--accent); }
    .large-map-tile.complete { background: var(--bg-completed); color: var(--text-completed); border-color: var(--border-completed); }
    .large-map-tile:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .settings-section { margin-bottom: 18px; }
    .settings-section-title {
      font-size: 0.75rem; text-transform: uppercase; font-weight: bold;
      color: var(--text-dim); letter-spacing: 1px; margin-bottom: 8px;
      padding-bottom: 4px; border-bottom: 1px solid var(--border-main);
    }
    .settings-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
    .settings-row-label { font-size: 1rem; color: var(--text-bright); }
    .settings-row-hint { font-size: 0.7rem; color: var(--text-dim); margin-top: 2px; }
    .settings-select {
      background: var(--bg-well); color: var(--text-main);
      border: 1px solid var(--border-main); padding: 5px 10px;
      font-family: 'Cabin Condensed'; cursor: pointer;
      font-size: 1rem; border-radius: 0; min-width: 140px;
    }
    .settings-select:focus { border-color: var(--accent); outline: none; }
    .settings-version {
      text-align: center; font-size: 0.7rem; color: var(--text-dim);
      margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-main);
    }

    .page-footer {
      width: 100%; max-width: 1580px; padding: 15px 0 10px 0;
      font-size: 0.65rem; color: var(--border-main);
      display: flex; align-items: center; gap: 6px; flex-wrap: wrap;
    }
    .sync-btn { cursor: pointer; color: var(--text-dim); text-decoration: underline; }
    .sync-btn:hover { color: var(--accent); }
    .sync-flash { animation: flash-sync 1s ease-out; }
    @keyframes flash-sync { 0% { color: var(--accent); } 100% { color: var(--border-main); } }
    .sync-error { color: var(--danger); }

    /* --- Event Description Bar --- */
    .event-desc-bar {
      width: 100%; max-width: 1580px;
      background: var(--bg-tile); border: 2px solid var(--border-main);
      padding: 10px 18px; margin-bottom: 14px;
      display: flex; justify-content: space-between; align-items: center;
      gap: 12px; border-left: 4px solid var(--accent);
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .event-desc-bar-content {
      display: flex; align-items: flex-start; gap: 10px;
      flex: 1; min-width: 0;
    }
    .event-desc-bar-icon {
      font-size: 1.1rem; flex-shrink: 0; line-height: 1.5;
    }
    .event-desc-bar-text {
      font-size: 0.85rem; color: var(--text-bright);
      line-height: 1.5; white-space: pre-line;
      overflow: hidden;
    }
    .event-desc-bar-close {
      background: none; border: none; color: var(--text-dim);
      font-size: 1.3rem; cursor: pointer; padding: 0 4px;
      line-height: 1; flex-shrink: 0;
      transition: color 0.2s ease;
    }
    .event-desc-bar-close:hover { color: var(--accent); }
    .event-desc-bar-close:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    /* --- Responsive --- */
    @media (max-width: 1400px) {
      .grid-container { grid-template-columns: repeat(var(--grid-cols-tablet, 5), 1fr); }
      .minimap-wrapper.in-dashboard { display: none; }
      .minimap-wrapper.floating {
        display: block; position: fixed; bottom: 20px; right: 20px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.7);
        background: var(--bg-well); border: 2px solid var(--border-main); z-index: 1000;
      }
      .minimap-wrapper.floating .minimap-container { grid-template-columns: repeat(var(--grid-cols, 7), 12px); grid-template-rows: repeat(var(--grid-rows, 7), 12px); }
      .minimap-wrapper.floating .mini-tile { width: 12px; height: 12px; font-size: 7px; }
    }
    @media (min-width: 1401px) { .minimap-wrapper.floating { display: none; } }
    @media (max-width: 1000px) { .grid-container { grid-template-columns: repeat(var(--grid-cols-mobile, 4), 1fr); } }
    @media (max-width: 768px) {
      body { padding: 8px; }
      .dashboard { padding: 8px 12px; gap: 6px; }
      .dashboard-main { flex-basis: calc(100% - 50px); }
      #event-title { font-size: 1.2rem; }
      #team-name { font-size: 0.9rem; }
      .stats-container { order: 3; flex-basis: 100%; justify-content: center; gap: 12px; padding-top: 6px; border-top: 1px solid var(--border-main); }
      .stat-value { font-size: 1.1rem; }
      #codeword-display { min-width: 70px; padding: 2px 8px; }
      .settings-btn { order: 2; }
      .event-desc-bar { padding: 8px 12px; }
      .event-desc-bar-text { font-size: 0.8rem; }
    }
    @media (max-width: 600px) {
      .grid-container { grid-template-columns: repeat(var(--grid-cols-small, 3), 1fr); }
      .dashboard { padding: 6px 10px; }
      #event-title { font-size: 1rem; }
      #team-name { font-size: 0.8rem; }
      .stats-container { gap: 10px; }
      .stat-label { font-size: 0.6rem; }
      .stat-value { font-size: 1rem; }
    }
    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; scroll-behavior: auto !important; }
      .tile:hover { transform: none !important; }
      .minimap-wrapper:hover { transform: none !important; }
    }
  </style>
</head>
<body>
  <header class="dashboard" role="banner">
    <div class="dashboard-main">
      <h1 id="event-title">Bingo 2026</h1>
      <p id="team-name">Loading Team...</p>
    </div>

    <div class="stats-container">
      <div class="stat-item">
        <span class="stat-label">Codeword</span>
        <span id="codeword-display" class="stat-value codeword-hidden"
              role="button" tabindex="0" aria-label="Codeword hidden. Click to reveal.">?????</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Points</span>
        <span id="total-points" class="stat-value" aria-live="polite">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Completed</span>
        <span id="completed-count" class="stat-value" aria-live="polite">0/49</span>
      </div>
    </div>

    <aside class="minimap-wrapper in-dashboard" id="mini-map-trigger"
           role="button" tabindex="0" aria-label="Open overview map">
      <div class="minimap-container" id="minimap" aria-hidden="true"></div>
    </aside>

    <a href="admin.html" class="settings-btn" id="admin-back-btn" style="display:none; margin-right:8px; text-decoration:none;" aria-label="Back to Admin">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
      <span>Admin</span>
    </a>
    <button class="settings-btn" id="settings-trigger" aria-label="Open settings">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.07.62-.07.94s.02.64.07.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6A3.6 3.6 0 1115.6 12 3.611 3.611 0 0112 15.6z"/>
      </svg>
    </button>
  </header>

  <aside class="minimap-wrapper floating" id="mini-map-floating"
         role="button" tabindex="0" aria-label="Open overview map">
    <div class="minimap-container" id="minimap-floating" aria-hidden="true"></div>
  </aside>

  <!-- Event Description -->
  <div class="event-desc-bar" id="event-desc-bar" style="display:none;">
    <div class="event-desc-bar-content">
      <span class="event-desc-bar-icon" style="display: flex; align-items: center;">
        <svg style="width: 1.4em; height: 1.4em; fill: currentColor;" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>
      </span>
      <span class="event-desc-bar-text" id="event-desc-bar-text"></span>
    </div>
    <button class="event-desc-bar-close" id="event-desc-bar-close" aria-label="Dismiss">&times;</button>
  </div>

  <main class="grid-container" id="grid" role="grid" aria-label="Bingo board"></main>

  <footer class="page-footer">
    <span>v3.342</span>
    <span>&middot;</span>
    <span id="last-sync-text" aria-live="polite">Last Sync: Never</span>
    <span class="sync-btn" id="sync-now" role="button" tabindex="0">[Sync Now]</span>
  </footer>

  <div id="modal-overlay" role="dialog" aria-modal="true" aria-label="Dialog">
    <div class="modal-content" id="modal-box" aria-label="Dialog panel">

      <!-- Standard Tile View -->
      <div id="standard-modal-view">
        <div class="modal-top-bar">
          <button class="modal-map-btn" id="modal-map-back" aria-label="Back to overview map" tabindex="0">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 3h8v8H3V3zm10 0h8v8h-8V3zM3 13h8v8H3v-8zm10 0h8v8h-8v-8z"/></svg>
          </button>
          <button class="modal-close-btn" aria-label="Close dialog" tabindex="0">&times;</button>
        </div>
        <div id="modal-header" class="modal-header"></div>
        <div class="modal-img"><img id="modal-image" src="" alt=""></div>
        <div id="modal-progress-section">
          <div class="modal-label">Progress</div>
          <div style="height: 12px; margin-bottom: 12px;">
            <div class="progress-bg"><div id="modal-bar" class="progress-fill"></div></div>
          </div>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 2px;">
          <div id="modal-checklist-label" class="modal-label">Checklist</div>
          <div id="modal-points" class="modal-points-inline">0 PTS</div>
        </div>
        <div id="modal-list" class="modal-checklist" style="max-height: 130px; margin-bottom: 12px;"></div>
        <div class="modal-label">Description</div>
        <div id="modal-desc" class="modal-description" style="max-height: 80px;"></div>
      </div>

      <!-- Map Overview View -->
      <div id="map-modal-view" style="display: none; flex-direction: column; align-items: center;">
        <div class="modal-top-bar" style="width: 100%;">
          <div></div>
          <button class="modal-close-btn" aria-label="Close dialog" tabindex="0">&times;</button>
        </div>
        <div class="modal-header" style="margin-top: 0;">OVERVIEW</div>
        <div class="large-map-grid" id="large-map-grid"></div>
      </div>

      <!-- Settings View -->
      <div id="settings-modal-view" style="display: none; flex-direction: column;">
        <div class="modal-top-bar">
          <div></div>
          <button class="modal-close-btn" aria-label="Close dialog" tabindex="0">&times;</button>
        </div>
        <div class="modal-header" style="margin-top: 0;">SETTINGS</div>

        <div style="max-height: 65vh; overflow-y: auto; padding-right: 4px;">
          <!-- Appearance Section -->
          <div class="settings-section">
            <div class="settings-section-title">Appearance</div>
            <div class="settings-row">
              <div>
                <div class="settings-row-label">Theme</div>
                <div class="settings-row-hint">Choose a visual style</div>
              </div>
              <label for="settings-theme-dropdown" class="sr-only">Select Theme</label>
              <select id="settings-theme-dropdown" class="settings-select">
              </select>
            </div>
          </div>

          <!-- Data Section -->
          <div class="settings-section">
            <div class="settings-section-title">Data</div>
            <div class="settings-row">
              <div>
                <div class="settings-row-label">Sync Interval</div>
                <div class="settings-row-hint">How often to refresh data</div>
              </div>
              <select id="settings-sync-interval" class="settings-select">
                <option value="15000">15 seconds</option>
                <option value="30000" selected>30 seconds</option>
                <option value="60000">1 minute</option>
                <option value="120000">2 minutes</option>
                <option value="300000">5 minutes</option>
              </select>
            </div>
          </div>
        </div>

        <div class="settings-version">Bingo Board &middot; v3.342</div>
      </div>
    </div>
  </div>

  <script src="js/themes.js"></script>
  <script>
(() => {
  const APP_VERSION = '3.342';
  let maxTiles = 49;
  let gridCols = 7;
  let gridRows = 7;

  const STORAGE_KEYS = {
    eventConfig: 'bingo-event-config',
    teams: 'bingo-teams-config',
    tiles: 'bingo-tiles-config',
    completion: 'bingo-completion',
    theme: 'bingo-theme',
    syncInterval: 'bingo-sync-interval',
    codewordVisible: 'bingo-codeword-visible'
  };

  const THEME_VARS = window.BINGO_THEME_VARS;
  const THEMES = window.BINGO_THEMES;

  const DEFAULT_TEAMS = {
    'Team 1': { name: "Team 1", url: "", points: 0, teamNumber: 1 },
    'Team 2': { name: "Team 2", url: "", points: 0, teamNumber: 2 },
    'Team 3': { name: "Team 3", url: "", points: 0, teamNumber: 3 },
    'Team 4': { name: "Team 4", url: "", points: 0, teamNumber: 4 },
    'Team 5': { name: "Team 5", url: "", points: 0, teamNumber: 5 },
    'Team 6': { name: "Team 6", url: "", points: 0, teamNumber: 6 },
    'Team 7': { name: "Team 7", url: "", points: 0, teamNumber: 7 },
    'Team 8': { name: "Team 8", url: "", points: 0, teamNumber: 8 }
  };

  let TEAM_MAP = {};
  let eventConfig = {
    name: 'Bingo 2026',
    codeword: '',
    description: '',
    syncInterval: 30000,
    format: '',
    boardSize: '',
    teamCount: '8', // Default to 8 for initial load if not in config
    masterCsvUrl: '', // New field for master CSV URL
    requirePasscodes: true
  };
  let currentTeamKey = '';
  let codewordSecret = '';
  let appliedHash = null;
  let candidateHash = null;
  let stabilityCount = 0;
  let completion = Array(maxTiles).fill(false);
  let tiles = Array(maxTiles).fill(null);
  let fetchController = null;
  let syncIntervalId = null;
  let syncMs = 30000;
  let modalOpen = false;
  let currentModalTileIndex = null;
  let lastTriggerEl = null;
  let ghostEl = null;

  async function loadSharedConfig() {
    let loadedRemote = false;
    try {
      const res = await fetch(withCacheBust('config.json'));
      if (res.ok) {
        const data = await res.json();
        if (data.eventConfig) eventConfig = { ...eventConfig, ...data.eventConfig };
        if (data.teams) TEAM_MAP = data.teams; // Load teams after eventConfig
        
        // Fallback for masterCsvUrl if missing in eventConfig but present in Team1
        if (!eventConfig.masterCsvUrl && data.teams) {
           if (data.teams.Team1?.url) eventConfig.masterCsvUrl = data.teams.Team1.url;
           else if (data.teams['Team 1']?.url) eventConfig.masterCsvUrl = data.teams['Team 1'].url;
        }
        
        loadedRemote = true;
      }
    } catch {}

    // Safety: If TEAM_MAP is empty (e.g. bad config or empty local storage), force defaults
    if (Object.keys(TEAM_MAP).length === 0) {
      TEAM_MAP = { ...DEFAULT_TEAMS };
    }

    // Apply board size if present in config
    if (eventConfig.boardSize) {
      updateBoardSize(eventConfig.boardSize);
    }

    // Get team from URL parameter
    const params = new URLSearchParams(window.location.search);
    const adminMode = params.get('admin') === 'true';
    
    const teamKeys = Object.keys(TEAM_MAP);
    const requestedTeamParam = params.get('team');

    // If requesting a specific team
    if (requestedTeamParam) {
      // Try to find by exact key (which is now the team name)
      if (TEAM_MAP[requestedTeamParam]) {
        currentTeamKey = requestedTeamParam;
      } else {
        // Try to find by teamNumber (for old links like ?team=Team1)
        const teamNumMatch = requestedTeamParam.match(/^Team(\d+)$/);
        if (teamNumMatch) {
          const teamNumber = parseInt(teamNumMatch[1], 10);
          const foundTeam = Object.values(TEAM_MAP).find(t => t.teamNumber === teamNumber);
          if (foundTeam) {
            currentTeamKey = foundTeam.name; // Use the actual name as the key
          } else {
            currentTeamKey = ''; // Team not found
          }
        } else {
          currentTeamKey = ''; // Invalid team requested
        }
      }
    } else if (adminMode && teamKeys.length > 0) {
      // Admin mode: show team selector
      // In admin mode, we might want to default to the first team in the config
      // or handle it differently. For now, let's default to the first team's name.
      currentTeamKey = Object.keys(TEAM_MAP)[0];
    } else if (teamKeys.length > 0) {
      // Non-admin: default to first team (shouldn't happen in production)
      currentTeamKey = Object.keys(TEAM_MAP)[0];
    } else {
      currentTeamKey = '';
    }
  }

  const $ = (id) => document.getElementById(id);
  const DOM = {
    teamName: $('team-name'),
    totalPoints: $('total-points'),
    completedCount: $('completed-count'),
    codeword: $('codeword-display'),
    grid: $('grid'),
    lastSync: $('last-sync-text'),
    syncNow: $('sync-now'),
    settingsTrigger: $('settings-trigger'),
    miniDash: $('mini-map-trigger'),
    miniFloat: $('mini-map-floating'),
    overlay: $('modal-overlay'),
    box: $('modal-box'),
    viewStd: $('standard-modal-view'),
    viewMap: $('map-modal-view'),
    viewSettings: $('settings-modal-view'),
    modalHeader: $('modal-header'),
    modalImage: $('modal-image'),
    modalProgressSection: $('modal-progress-section'),
    modalBar: $('modal-bar'),
    modalList: $('modal-list'),
    modalChecklistLabel: $('modal-checklist-label'),
    modalDesc: $('modal-desc'),
    modalPoints: $('modal-points'),
    mapBack: $('modal-map-back'),
    bigMap: $('large-map-grid'),
    themeSel: $('settings-theme-dropdown'),
    intervalSel: $('settings-sync-interval'),
    descBar: $('event-desc-bar'),
    descBarText: $('event-desc-bar-text'),
    descBarClose: $('event-desc-bar-close'),
  };

  const updateThemeDropdownVisuals = () => {
    if (!DOM.themeSel) return;
    const defaultStyle = { '--bg-tile': '#494034', '--text-main': '#ffac00' };
    Array.from(DOM.themeSel.options).forEach(opt => {
      const t = THEMES[opt.value] || defaultStyle;
      if (t) {
        opt.style.backgroundColor = t['--bg-tile'] || t['--bg-body'];
        opt.style.color = t['--text-main'];
      }
    });
  };

  let miniNodes = [];

  /* ========================= UTILS ========================= */
  const storageSave = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };
  const storageLoad = (k, fb) => {
    try {
      const v = localStorage.getItem(k);
      return v ? JSON.parse(v) : fb;
    } catch {
      return fb;
    }
  };
  const normalizeNL = (s) => String(s).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const simpleHash = (str) => {
    let h = 0;
    for (let i = 0; i < str.length; i++) { h = ((h << 5) - h) + str.charCodeAt(i); h |= 0; }
    return h;
  };
  const escapeHTML = (str) => {
    const d = document.createElement('div');
    d.appendChild(document.createTextNode(String(str ?? '')));
    return d.innerHTML;
  };

  const parseCSVRow = (row) => {
    const cols = []; let cur = '', inQ = false;
    for (let i = 0; i < row.length; i++) {
      const ch = row[i];
      if (inQ) {
        if (ch === '"' && row[i + 1] === '"') { cur += '"'; i++; }
        else if (ch === '"') inQ = false;
        else cur += ch;
      } else {
        if (ch === '"') inQ = true;
        else if (ch === ',') { cols.push(cur.trim()); cur = ''; }
        else cur += ch;
      }
    }
    cols.push(cur.trim());
    return cols;
  };

  const withCacheBust = (url) => {
    const u = String(url || '').trim();
    if (!u) return '';
    return u + (u.includes('?') ? '&' : '?') + 't=' + Date.now();
  };

  const getProgressColor = (pct) => {
    if (pct >= 100) return 'var(--text-completed)';
    const hue = (pct * 120) / 100;
    return `hsl(${hue}, 70%, 45%)`;
  };

  const handleImgError = (img) => {
    img.style.visibility = 'hidden';
    img.removeAttribute('src');
  };

  const safeImgSrc = (imgName) => {
    const raw = String(imgName || '').trim();
    if (!raw) return '';
    if (/^https?:\/\//i.test(raw)) return raw;
    const parts = raw.replace(/\\/g, '/').split('/').filter(Boolean).filter(p => p !== '.' && p !== '..');
    return `./images/${parts.map(encodeURIComponent).join('/')}`;
  };

  const setMinimapComplete = (id1, done) => {
    for (const n of miniNodes[id1]) n.classList.toggle('complete', !!done);
  };
  const resetMinimaps = () => { for (let i = 1; i <= maxTiles; i++) setMinimapComplete(i, false); };
  const updateCompletedStat = () => {
    const done = completion.reduce((a, v) => a + (v ? 1 : 0), 0);
    DOM.completedCount.innerText = `${done}/${maxTiles}`;
  };
  const flashSync = () => {
    DOM.lastSync.classList.remove('sync-error');
    DOM.lastSync.innerText = `Last Sync: ${new Date().toLocaleTimeString()}`;
    DOM.lastSync.classList.remove('sync-flash');
    void DOM.lastSync.offsetWidth;
    DOM.lastSync.classList.add('sync-flash');
  };
  const syncError = (msg) => {
    DOM.lastSync.classList.add('sync-error');
    DOM.lastSync.innerText = `Sync failed: ${msg}`;
  };

  const calculateBingos = (grid, cols, rows) => {
    let rCount = 0, cCount = 0, dCount = 0;
    // Rows
    for (let r = 0; r < rows; r++) {
      let full = true;
      for (let c = 0; c < cols; c++) {
        if (!grid[r * cols + c]) { full = false; break; }
      }
      if (full) rCount++;
    }
    // Cols
    for (let c = 0; c < cols; c++) {
      let full = true;
      for (let r = 0; r < rows; r++) {
        if (!grid[r * cols + c]) { full = false; break; }
      }
      if (full) cCount++;
    }
    // Diagonals (if square)
    if (cols === rows) {
      let full1 = true;
      for (let i = 0; i < cols; i++) {
        if (!grid[i * cols + i]) { full1 = false; break; }
      }
      if (full1) dCount++;
      let full2 = true;
      for (let i = 0; i < cols; i++) {
        if (!grid[i * cols + (cols - 1 - i)]) { full2 = false; break; }
      }
      if (full2) dCount++;
    }
    return { rows: rCount, cols: cCount, diags: dCount };
  };

  /* ========================= THEME APPLY ========================= */
  const applyTheme = (name) => {
    const root = document.documentElement;
    for (const k of THEME_VARS) root.style.setProperty(k, '');
    const t = THEMES[name];
    if (t) for (const [k, v] of Object.entries(t)) root.style.setProperty(k, v);
    storageSave(STORAGE_KEYS.theme, name);
    if (DOM.themeSel) DOM.themeSel.value = name;
  };

  /* ========================= MINIMAPS BUILD ========================= */
  const buildMinimap = (containerId) => {
    const el = $(containerId);
    if (!el) return;
    el.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (let i = 1; i <= maxTiles; i++) {
      const d = document.createElement('div');
      d.className = 'mini-tile';
      d.dataset.index = String(i);
      d.innerText = String(i);
      frag.appendChild(d);
      if (!miniNodes[i]) miniNodes[i] = [];
      miniNodes[i].push(d);
    }
    el.appendChild(frag);
  };

  /* ========================= RENDER ========================= */
  const renderGrid = () => {
    const container = $('grid');
    if (!container) return;
    container.innerHTML = '';

    for (let i = 0; i < tiles.length; i++) {
      const tile = tiles[i];
      
      const cell = document.createElement('div');
      cell.className = 'tile' + (tile.isCompleted ? ' completed' : '') + (tile.noData ? ' no-data' : '');
      cell.id = 'tile-' + tile.id;
      cell.dataset.tileIndex = String(i);
      cell.setAttribute('role', 'button');
      cell.setAttribute('tabindex', '0');

      const headerBox = document.createElement('div');
      headerBox.className = 'header-box';
      headerBox.innerHTML = `<div class="header-content">${tile.id} | ${escapeHTML(tile.title)}</div>`;

      const imgContainer = document.createElement('div');
      imgContainer.className = 'img-container';
      if (tile.img) {
        const img = document.createElement('img');
        img.src = tile.img;
        img.alt = escapeHTML(tile.title);
        img.onerror = () => handleImgError(img);
        imgContainer.appendChild(img);
      }

      const progressContainer = document.createElement('div');
      progressContainer.className = 'progress-container';
      progressContainer.innerHTML = `
        <div class="progress-bg">
          <div class="progress-fill" style="width:${tile.percent}%; background-color:${tile.barColor};"></div>
        </div>
      `;

      const checklistBox = document.createElement('div');
      checklistBox.className = 'checklist-box';
      checklistBox.innerHTML = tile.gridChecklistHtml || '';

      const pointBadge = document.createElement('div');
      pointBadge.className = 'point-badge';
      pointBadge.textContent = `${tile.points} PTS`;

      cell.appendChild(headerBox);
      cell.appendChild(imgContainer);
      cell.appendChild(progressContainer);
      cell.appendChild(checklistBox);
      cell.appendChild(pointBadge);

      cell.addEventListener('click', () => openTileModalByIndex(i, cell));
      cell.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          openTileModalByIndex(i, cell);
        }
      });

      container.appendChild(cell);
    }
  };

  const buildBigMap = () => {
    DOM.bigMap.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (let i = 1; i <= maxTiles; i++) {
      const cell = document.createElement('div');
      cell.className = `large-map-tile${completion[i - 1] ? ' complete' : ''}`;
      cell.dataset.index = String(i);
      cell.innerText = String(i);
      cell.tabIndex = 0;
      cell.setAttribute('role', 'button');
      frag.appendChild(cell);
    }
    DOM.bigMap.appendChild(frag);
  };

  /* ========================= MODAL ========================= */
  const hideViews = () => {
    DOM.viewStd.style.display = 'none';
    DOM.viewMap.style.display = 'none';
    DOM.viewSettings.style.display = 'none';
  };

  const showModal = (triggerEl, animate = true) => {
    if (ghostEl?.isConnected) ghostEl.classList.remove('ghost');
    lastTriggerEl = triggerEl || lastTriggerEl;
    ghostEl = triggerEl;
    if (ghostEl?.classList?.contains('tile') || ghostEl?.id === 'mini-map-trigger' || ghostEl?.id === 'mini-map-floating') {
      ghostEl.classList.add('ghost');
    }
    const rect = (animate && triggerEl?.getBoundingClientRect)
      ? triggerEl.getBoundingClientRect()
      : { top: innerHeight / 2, left: innerWidth / 2, height: 0, width: 0 };
    DOM.box.style.top = (rect.top + rect.height / 2) + 'px';
    DOM.box.style.left = (rect.left + rect.width / 2) + 'px';
    DOM.overlay.style.display = 'flex';
    setTimeout(() => {
      DOM.overlay.classList.add('active');
      DOM.box.classList.add('active');
      modalOpen = true;
      DOM.box.querySelector('.modal-close-btn')?.focus();
    }, 10);
    document.body.style.overflow = 'hidden';
  };

  const closeModal = () => {
    DOM.overlay.classList.remove('active');
    DOM.box.classList.remove('active');
    modalOpen = false;
    currentModalTileIndex = null;
    if (ghostEl?.isConnected) ghostEl.classList.remove('ghost');
    setTimeout(() => {
      DOM.overlay.style.display = 'none';
      document.body.style.overflow = 'auto';
      lastTriggerEl?.focus?.();
    }, 500);
  };

  const updateModalContent = (t) => {
    DOM.box.classList.toggle('completed', !!t.isCompleted);
    DOM.modalHeader.innerText = `${t.id} | ${t.title}`;
    DOM.modalPoints.innerText = `${t.points} PTS`;
    DOM.modalProgressSection.style.display = t.isCompleted ? 'none' : 'block';
    DOM.modalBar.style.width = t.percent + '%';
    DOM.modalBar.style.backgroundColor = t.barColor;
    DOM.modalList.innerHTML = t.modalChecklistHtml || '';
    DOM.modalDesc.innerText = t.description || '(No description)';

    if (DOM.modalChecklistLabel) {
      DOM.modalChecklistLabel.innerText = (t.requiredCount > 0)
        ? `Checklist (${t.collectedCount}/${t.requiredCount})`
        : 'Checklist';
    }
    
    DOM.modalImage.alt = t.title;
    DOM.modalImage.onerror = () => handleImgError(DOM.modalImage);
    
    if (t.img) {
      if (DOM.modalImage.getAttribute('src') !== t.img) {
        DOM.modalImage.style.visibility = 'visible';
        DOM.modalImage.src = t.img;
      }
    } else {
      handleImgError(DOM.modalImage);
    }
  };

  const openTileModalByIndex = (tileIndex, triggerEl) => {
    const t = tiles[tileIndex];
    if (!t || t.noData) return;
    
    currentModalTileIndex = tileIndex;
    hideViews();
    DOM.viewStd.style.display = 'block';
    
    DOM.modalImage.src = '';
    DOM.modalImage.style.visibility = 'visible';
    updateModalContent(t);
    
    showModal(triggerEl, true);
  };

  const openMapModal = (triggerEl) => {
    DOM.box.classList.remove('completed');
    hideViews();
    DOM.viewMap.style.display = 'flex';
    buildBigMap();
    showModal(triggerEl, true);
  };

  const openSettingsModal = (triggerEl) => {
    DOM.box.classList.remove('completed');
    hideViews();
    DOM.viewSettings.style.display = 'flex';
    DOM.themeSel.value = storageLoad(STORAGE_KEYS.theme, 'osrs');
    DOM.intervalSel.value = String(syncMs);
    showModal(triggerEl, true);
  };

  /* ========================= CODEWORD ========================= */
  const setCodewordVisible = (visible) => {
    DOM.codeword.classList.toggle('codeword-hidden', !visible);
    DOM.codeword.innerText = visible ? (codewordSecret || '') : '?????';
    DOM.codeword.setAttribute('aria-label',
      visible ? `Codeword: ${codewordSecret}. Click to hide.` : 'Codeword hidden. Click to reveal.'
    );
    storageSave(STORAGE_KEYS.codewordVisible, visible ? '1' : '0');
  };
  const toggleCodeword = () => setCodewordVisible(DOM.codeword.classList.contains('codeword-hidden'));

  /* ========================= FETCH ========================= */
  const fetchGlobal = () => {
    // Update event title
    const titleEl = document.getElementById('event-title');
    if (titleEl) titleEl.innerText = eventConfig.name || 'Bingo 2026';

    if (!currentTeamKey || !TEAM_MAP[currentTeamKey]) {
      DOM.teamName.innerText = 'No team configured';
      DOM.totalPoints.innerText = '0';
      codewordSecret = '';
      return;
    }

    const t = TEAM_MAP[currentTeamKey];
    DOM.teamName.innerText = t.name || currentTeamKey;
    DOM.totalPoints.innerText = Number(t.points || 0).toLocaleString();
    codewordSecret = eventConfig.codeword || '';
  };

  const renderEventDescription = () => {
    if (!eventConfig.description || !eventConfig.description.trim()) {
      DOM.descBar.style.display = 'none';
      return;
    }
    
    const dismissed = sessionStorage.getItem('bingo-desc-dismissed');
    if (dismissed === '1') {
      DOM.descBar.style.display = 'none';
      return;
    }
    
    DOM.descBarText.textContent = eventConfig.description;
    DOM.descBar.style.display = 'flex';
  };

  const updateBoardSize = (sizeStr) => {
    let c = 7, r = 7;
    if (sizeStr && typeof sizeStr === 'string') {
      const parts = sizeStr.toLowerCase().split('x');
      if (parts.length === 2) {
        c = parseInt(parts[0].trim()) || 7;
        r = parseInt(parts[1].trim()) || 7;
      }
    }
    if (c !== gridCols || r !== gridRows) {
      gridCols = c; gridRows = r; maxTiles = c * r;
      document.documentElement.style.setProperty('--grid-cols', gridCols);
      document.documentElement.style.setProperty('--grid-rows', gridRows);
      document.documentElement.style.setProperty('--grid-cols-tablet', Math.min(5, gridCols));
      document.documentElement.style.setProperty('--grid-cols-mobile', Math.min(4, gridCols));
      document.documentElement.style.setProperty('--grid-cols-small', Math.min(3, gridCols));
    }
  };

  async function fetchData(manual = false) {
    // Guard: no team configured
    if (!currentTeamKey || !TEAM_MAP[currentTeamKey]) {
      console.warn('No team configured, skipping fetch.');
      syncError('No team configured');

      // Fill grid with empty tiles so it doesn't stay blank
      tiles = Array(maxTiles).fill(null).map((_, i) => ({
        id: i + 1, title: 'No Data', img: '', percent: 0, barColor: getProgressColor(0), 
        gridChecklistHtml: '', modalChecklistHtml: '', description: '', 
        isCompleted: false, points: '0', noData: true, collectedCount: 0, requiredCount: 0
      }));
      renderGrid();
      updateCompletedStat();
      return;
    }

    if (fetchController) fetchController.abort();
    fetchController = new AbortController();

    try {
      const team = TEAM_MAP[currentTeamKey];

      if (!eventConfig.masterCsvUrl) { // Use masterCsvUrl from eventConfig
        syncError('No CSV URL configured');
        return;
      }

      const res = await fetch(withCacheBust(eventConfig.masterCsvUrl), { // Use masterCsvUrl
        headers: { 'pragma': 'no-cache', 'cache-control': 'no-cache' },
        signal: fetchController.signal
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const raw = normalizeNL(await res.text());
      if (fetchController?.signal.aborted) return;
      const h = simpleHash(raw);

      const lines = raw.split('\n');

      // Always parse metadata to ensure board size/config is correct,
      // overriding any stale values from config.json (e.g. on tab switch)
      if (lines.length > 1) {
        const metaCols = parseCSVRow(lines[1].trim()); // Row 1 is metadata
        // Update eventConfig from CSV metadata
        eventConfig.name = metaCols[0] || eventConfig.name;
        eventConfig.description = metaCols[1] || eventConfig.description;
        eventConfig.codeword = metaCols[2] || eventConfig.codeword;
        eventConfig.format = metaCols[3] || eventConfig.format;
        eventConfig.boardSize = metaCols[4] || eventConfig.boardSize;
        eventConfig.teamCount = metaCols[5] || eventConfig.teamCount;
        updateBoardSize(eventConfig.boardSize);

        // Update TEAM_MAP with names from CSV (vertical column 6)
        const currentTeamCount = parseInt(eventConfig.teamCount, 10);
        const updatedTeamMap = {};
        for (let i = 1; i <= currentTeamCount; i++) {
          if (lines[i]) { // Check if line exists for team number
            const teamRowCols = parseCSVRow(lines[i]);
            const teamNameFromCSV = teamRowCols[6] || `Team ${i}`;
            const existingTeamData = Object.values(TEAM_MAP).find(t => t.teamNumber === i) || { teamNumber: i };
            updatedTeamMap[teamNameFromCSV] = { ...existingTeamData, name: teamNameFromCSV };
          }
        }
        TEAM_MAP = updatedTeamMap;
      }

      if (manual) {
        // Manual sync: trust immediately
        appliedHash = h;
        candidateHash = null;
        stabilityCount = 0;
      } else {
        // Auto sync: Stability Check
        if (appliedHash === null) {
          appliedHash = h;
        } else if (h === appliedHash) {
          candidateHash = null;
          stabilityCount = 0;
          return; // No change
        } else {
          if (h === candidateHash) {
            stabilityCount++;
          } else {
            candidateHash = h;
            stabilityCount = 1;
          }
          if (stabilityCount < 3) return; // Wait for confirmation
          
          appliedHash = h;
          candidateHash = null;
          stabilityCount = 0;
        }
      }

      flashSync();

      // Parse Metadata from first data row (index 1) BEFORE init arrays
      // Parse Bonuses from new Col 12 (M) in Rows 2, 3, 4 (Indices 1, 2, 3)
      let rowBonus = 0, colBonus = 0, diagBonus = 0;
      if (lines[1]) { const c = parseCSVRow(lines[1]); rowBonus = parseInt(c[12]) || 0; }
      if (lines[2]) { const c = parseCSVRow(lines[2]); colBonus = parseInt(c[12]) || 0; }
      if (lines[3]) { const c = parseCSVRow(lines[3]); diagBonus = parseInt(c[12]) || 0; }
      
      completion = Array(maxTiles).fill(false);
      tiles = Array(maxTiles).fill(null);
      miniNodes = Array.from({ length: maxTiles + 1 }, () => []);
      buildMinimap('minimap');
      buildMinimap('minimap-floating');

      // Find the team object by its name (currentTeamKey)
      const currentTeamObject = TEAM_MAP[currentTeamKey];
      if (!currentTeamObject) throw new Error(`Team ${currentTeamKey} not found in TEAM_MAP.`);
      const teamNumber = currentTeamObject.teamNumber || 1;
      
      // Calculate which columns belong to this team
      // New Format: Metadata(0-6) | TileData(7-10) | TileItemList(11) | Bonus(12) | TeamData(13+)
      const itemsCol = 13 + ((teamNumber - 1) * 3); // This is the team's collected items, not used for checklist
      const currentCol = 14 + ((teamNumber - 1) * 3);
      const goalCol = 15 + ((teamNumber - 1) * 3);
      const rows = lines.slice(1);
      let count = 0;
      let calculatedPoints = 0;

      // Helper to robustly parse comma-separated values from a single CSV cell.
      // Handles leading/trailing whitespace, and stray commas at the start/end of the list.
      const parseList = (str) => {
        if (!str) return [];
        const cleanedStr = String(str).trim().replace(/^,+/,'').replace(/,+$/,'');
        if (!cleanedStr) return [];
        return cleanedStr.split(',').map(s => s.trim()).filter(s => s);
      };

      console.log(`Team: ${currentTeamKey} (Team Number: ${teamNumber}), Columns: Items=${itemsCol}, Current=${currentCol}, Goal=${goalCol}`);

      // Update event title and description from eventConfig (already updated from CSV metadata)
      const titleEl = document.getElementById('event-title');
      if (titleEl) titleEl.innerText = eventConfig.name;
      codewordSecret = eventConfig.codeword;
      renderEventDescription();

      // Process tiles
      for (let i = 0; i < maxTiles; i++) {
        const lineIndex = i + 1; // CSV rows are 0-indexed, but tile data starts from line 1 (after header)
        if (lineIndex >= lines.length || !lines[lineIndex].trim()) {
          tiles[i] = { id: i + 1, title: 'No Data', img: '', percent: 0, barColor: getProgressColor(0), gridChecklistHtml: '', modalChecklistHtml: '', description: '', isCompleted: false, points: '0', noData: true, collectedCount: 0, requiredCount: 0 };
          continue;
        }
        
        const cols = parseCSVRow(lines[lineIndex].trim());
        if (cols.length < 11) {
          tiles[i] = { id: i + 1, title: 'No Data', img: '', percent: 0, barColor: getProgressColor(0), gridChecklistHtml: '', modalChecklistHtml: '', description: '', isCompleted: false, points: '0', noData: true, collectedCount: 0, requiredCount: 0 };
          continue;
        }

        const id = i + 1;
        const img = safeImgSrc(cols[7] || '');
        const title = cols[8] || `Tile ${id}`;
        const description = cols[9] || '';
        const pointsVal = parseInt(cols[10], 10) || 0;
        const requiredItems = cols[11] ? cols[11].split(',').map(s => s.trim()).filter(s => s) : [];
        
        // This is the team's collected items
        const collectedItemsRaw = cols[itemsCol] ? cols[itemsCol].split(',').map(s => s.trim()).filter(s => s) : [];
        const collectedItemsSet = new Set(collectedItemsRaw);
        
        const current = Math.max(0, parseInt(cols[currentCol], 10) || 0);
        const goal = Math.max(1, parseInt(cols[goalCol], 10) || 1);
        const percent = Math.min((current / goal) * 100, 100);
        const isCompleted = percent === 100;
        if (isCompleted) calculatedPoints += pointsVal;
        
        completion[i] = isCompleted;
        setMinimapComplete(id, isCompleted);
        
        // Checklist for the grid (only collected items)
        const gridChecklistHtml = collectedItemsRaw.map(it =>
          `<div class="check-item"><span class="check-mark"></span> ${escapeHTML(it)}</div>`
        ).join('');
        
        // Checklist for the modal (all required items, styled based on collection status)
        const modalChecklistHtml = requiredItems.map(it => {
          const isCollected = collectedItemsSet.has(it);
          return `<div class="check-item${isCollected ? '' : ' uncollected'}"><span class="check-mark"></span> ${escapeHTML(it)}</div>`;
        }).join('');
        
        tiles[i] = { id, title, img, percent, barColor: getProgressColor(percent), gridChecklistHtml, modalChecklistHtml, description, isCompleted, points: pointsVal, noData: false, collectedCount: collectedItemsSet.size, requiredCount: requiredItems.length };
      }

      const bingoStats = calculateBingos(completion, gridCols, gridRows);
      calculatedPoints += (bingoStats.rows * rowBonus) + (bingoStats.cols * colBonus) + (bingoStats.diags * diagBonus);

      DOM.totalPoints.innerText = calculatedPoints.toLocaleString();
      if (TEAM_MAP[currentTeamKey]) TEAM_MAP[currentTeamKey].points = calculatedPoints;

      renderGrid();
      updateCompletedStat();

      if (modalOpen && currentModalTileIndex !== null) {
        const t = tiles[currentModalTileIndex];
        if (t) updateModalContent(t);
      }
    } catch (e) {
      if (e.name !== 'AbortError') { console.error(e); syncError('Network error'); }
    } finally { fetchController = null; }
  }

  /* ========================= EVENTS & INIT ========================= */
  function trapFocus(e) {
    if (!modalOpen || e.key !== 'Tab') return;
    const focusable = [...DOM.box.querySelectorAll('button,select,input,textarea,[tabindex]:not([tabindex="-1"])')]
      .filter(el => !el.disabled && el.offsetParent !== null);
    if (!focusable.length) return;
    const first = focusable[0], last = focusable[focusable.length - 1];
    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
  }

  function restartInterval() {
    if (syncIntervalId) clearInterval(syncIntervalId);
    syncIntervalId = setInterval(() => fetchData(false), syncMs);
  }

  async function init() {
    // Load shared config FIRST
    await loadSharedConfig();

    // Check if we came from admin page
    const params = new URLSearchParams(window.location.search);
    if (params.get('fromAdmin') === 'true') {
      const backBtn = $('admin-back-btn');
      if (backBtn) backBtn.style.display = 'flex';
    }

    // Populate standard themes
    if (DOM.themeSel && window.BINGO_THEME_METADATA) {
      window.BINGO_THEME_METADATA.forEach(meta => {
        const opt = document.createElement('option');
        opt.value = meta.value;
        opt.textContent = meta.label;
        DOM.themeSel.appendChild(opt);
      });
    }

    const savedTheme = storageLoad(STORAGE_KEYS.theme, 'osrs');
    applyTheme(savedTheme);

    syncMs = parseInt(storageLoad(STORAGE_KEYS.syncInterval, String(eventConfig.syncInterval || 30000)), 10) || 30000;
    DOM.intervalSel.value = String(syncMs);

    miniNodes = Array.from({ length: maxTiles + 1 }, () => []);
    buildMinimap('minimap');
    buildMinimap('minimap-floating');

    fetchGlobal();
    setCodewordVisible(storageLoad(STORAGE_KEYS.codewordVisible, '0') === '1');

    // Event description
    renderEventDescription();
    if (DOM.descBarClose) {
      DOM.descBarClose.addEventListener('click', () => {
        DOM.descBar.style.display = 'none';
        try { sessionStorage.setItem('bingo-desc-dismissed', '1'); } catch {}
      });
    }

    // Codeword
    DOM.codeword.addEventListener('click', toggleCodeword);
    DOM.codeword.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleCodeword(); }
    });

    // Minimap
    const wireMapOpen = (el) => {
      el.addEventListener('click', () => openMapModal(el));
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openMapModal(el); }
      });
    };
    wireMapOpen(DOM.miniDash);
    wireMapOpen(DOM.miniFloat);

    // Big map tiles
    DOM.bigMap.addEventListener('click', (e) => {
      const cell = e.target.closest('.large-map-tile');
      if (!cell) return;
      const id = parseInt(cell.dataset.index, 10);
      if (!id) return;
      openTileModalByIndex(id - 1, cell);
    });

    DOM.bigMap.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter' && e.key !== ' ') return;
      const cell = e.target.closest('.large-map-tile');
      if (!cell) return;
      e.preventDefault();
      const id = parseInt(cell.dataset.index, 10);
      if (!id) return;
      openTileModalByIndex(id - 1, cell);
    });

    // Settings
    DOM.settingsTrigger.addEventListener('click', () => openSettingsModal(DOM.settingsTrigger));
    updateThemeDropdownVisuals();

    // Theme dropdown change
    DOM.themeSel.addEventListener('change', () => {
      const name = DOM.themeSel.value;
      applyTheme(name);
    });

    // Sync interval change
    DOM.intervalSel.addEventListener('change', () => {
      syncMs = parseInt(DOM.intervalSel.value, 10) || 30000;
      storageSave(STORAGE_KEYS.syncInterval, syncMs);
      restartInterval();
    });

    // Modal close
    DOM.overlay.addEventListener('click', (e) => { if (e.target === DOM.overlay) closeModal(); });
    document.querySelectorAll('.modal-close-btn').forEach(btn => btn.addEventListener('click', closeModal));

    // Map back button
    DOM.mapBack.addEventListener('click', () => {
      DOM.box.classList.remove('completed');
      if (ghostEl?.isConnected) ghostEl.classList.remove('ghost');
      ghostEl = null;
      hideViews();
      DOM.viewMap.style.display = 'flex';
      buildBigMap();
    });

    // Sync now
    DOM.syncNow.addEventListener('click', () => fetchData(true));
    DOM.syncNow.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fetchData(true); }
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (modalOpen && e.key === 'Escape') closeModal();
      trapFocus(e);
    });

    // Visibility
    document.addEventListener('visibilitychange', async () => {
      if (document.hidden) {
        if (syncIntervalId) clearInterval(syncIntervalId);
        syncIntervalId = null;
      } else {
        await loadSharedConfig();
        const savedTheme = storageLoad(STORAGE_KEYS.theme, 'osrs'); // Re-apply theme
        applyTheme(savedTheme);
        fetchGlobal();
        restartInterval();
        fetchData(false);
      }
    });

    fetchData(false);
    restartInterval();
  }

  init();
})();
  </script>
</body>
</html>
